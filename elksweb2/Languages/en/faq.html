<br>
This a list of answers to Frequently Asked Questions about ELKS, also known as Linux-8086.<br>      
Note that ELKS is not Linux, and the mailing list is <i>not</i> a suitable place for posting questions about Linux (despite its name). These would be better sent to one of the Linux-specific newsgroups such as <a href="news:comp.os.linux.misc">comp.os.linux.misc</a> or similar.
      
<hr align="center" width="90%">

<ol><li><h2><a href="#1">General</a></h2>
		<ol><li><a href="#1.1">What is ELKS ?</a>
        	<li><a href="#1.2">How does ELKS compare with standard  Linux ?</a>
			<li><a href="#1.3">Are there any ready-to-run distributions of ELKS ?</a>
			<li><a href="#1.4">Can ELKS run on an 8088 ?</a>
        	<li><a href="#1.5">What about the 80188 and 80186 processors ?</a>
			<li><a href="#1.6">What about the NEC V20 and V30 processors ?</a></ol>
    <li><h2><a href="#2">Compiling and installing</a></h2>
		<ol><li><a href="#2.1">Where can I find the source for ELKS ?</a>
			<li><a href="#2.2">How do I make an ELKS kernel ?</a>
			<li><a href="#2.3">I get an error saying that /usr/include/linux/vm86.h does not exist ?</a>
			<li><a href="#2.4">How do I make an 'init' for ELKS  ?</a>
			<li><a href="#2.5">How do I make a root filesystem disk ?</a>
			<li><a href="#2.6">What if I have an XT with a 360K disk drive ?</a>
			<li><a href="#2.7">How do a change root device of boot images ?</a>
			<li><a href="#2.8">How do I install to a hard drive  ?</a>
			<li><a href="#2.9">I get errors building Dev86 on recent Linux systems ?</a>
			<li><a href="#2.10">I get errors building elkscmd ?</a>
			<li><a href="#2.11">I get warnings building elkscmd  ?</a></ol>
	<li><h2><a href="#3">Using ELKS</a></h2>
		<ul><li><a href="#3.1">Can I run bcc binaries under Linux ?</a>
			<li><a href="#3.2">Can I boot ELKS under DOSEMU ?</a></ul>
</ol>
<ul><li><h2><a href="#4">Contributing to ELKS</a></h2>
		<ol><li><a href="#4.1">Can I contribute to the ELKS project ?</a>
			<li><a href="#4.2">What needs to be done ?</a>
    		<li><a href="#4.3">What is CVS ?</a>
			<li><a href="#4.4">Where do I get CVS from ?</a>
			<li><a href="#4.5">How do I use CVS without an account ?</a></ol>
	<li><h2><a href="#5">Unanswered questions</a></h2>
		<ol><li><a href="#5.1">Can I start ELKS from DOS, like LOADLIN.EXE does for Linux ?</a>
			<li><a href="#5.2">My palmtop has a RAMdrive. Can ELKS access it ?</a> <i>(When/if ELKS gets an msdos filesystem, that is)</i>
			<li><a href="#5.3">Can I combine the boot and root floppies ?</a></ol>
</ul>

<hr align="center" width="90%">      
<br>
<h3><a name="1">Section 1 - General</a></h3>
<h4><a name="1.1">Q1.1. What is ELKS?</a></h4>
ELKS is the Embeddable Linux Kernel Subset, a project to build a small kernel subset of Linux (which will provide more  or less UNIX V7 functionality within the kernel) that can run on machines  with limited processor and memory resources. More information on the background,  goals and current status of the project can be found at the <a href="http://elks.sf.net/">ELKS home page</a>.<br>
The initial proposed targets are the Intel 8086 and eventually the 286's 16-bit protected mode. A kernel that can run on this kind of hardware is useful for embedded systems projects, for third world deployment where 80x86 x&gt;0 machines are not easily available, and for use on various palmtops.<br>

<h4><a name="1.2">Q1.2. How does ELKS compare with standard Linux?</a></h4>
ELKS is intended to be a subset of true  Linux, and ought to be small enough to be understood by one person, so it should be invaluable as a learning tool. ELKS recently entered the beta development state and most of it's functionality is there.<br>
Having said that, it is already able to  boot, provide virtual consoles, mount minix filesystems, provide basic serial and parallel I/O, connect to another computer over a null-modem SLIP link. Finally ELKS supports swapping to virtualy enlarge the system RAM.<br>

<h4><a name="1.3">Q1.3. Are there any ready-to-run distributions of ELKS?</a></h4>
Not yet. You need to use a standard Linux machine, download the sources, and cross-compile to generate the 8086 target code. Boot and root disk images are provided with the current version of ELKS, but all they do is act as a platform for testing the system, and very little can be done with them.<br>
If you are interested in building a distribution around ELKS, you are welcome.<br>

<h4><a name="1.4">Q1.4. Can ELKS run on an 8088?</a></h4>
The 8088 is identical to the 8086, except it has an 8-bit external data bus instead of 16-bit (and thus is slower). So yes, ELKS will run on it.<br>

<h4><a name="1.5">Q1.5. What about the 80188 and 80186 processors?</a></h4>
These are simply high-integration versions of the 8088 and 8086 respectively, so yes, ELKS will run on them.<br>

<h4><a name="1.6">Q1.6. What about the NEC V20 and V30 processors?</a></h4>
From a software viewpoint, these are simply 8088 and 8086 processors respectively, with the sole exception that the AAD instruction can not be used with bases other than decimal on the V20 and V30, whereas it can be used with other bases on the 8088 and 8086 processors.<br>
This difference will not prevent ELKS from running on these processors, and it is believed that the kernel is not affected by this difference, but user  reports would be appreciated.<br>

<hr align="center" width="90%"><br>
<h3><a name="2">Section 2 - Compiling and Installing</a></h3>
<h4><a name="2.1">Q2.1. Where can I find the source?</a></h4>
The primary site <a href="http://elks.sf.net/">http://elks.sf.net</a><br>
The primary site for Dev86 is <a href="http://www.cix.co.uk/%7Emayday/">http://www.cix.co.uk/~mayday/</a> which is the best place to find the latest version.<br>         
If you know of any others or wish to set one up, please contact the maintainer.<br>
<h4><a name="2.2">Q2.2. How do I make an ELKS kernel?</a></h4>
Recent releases contain a conmpiled binary kernel which most people whould be able to use for initial testing. You should only need to compile your own if you wish to modify the kernel, or change the configuration options. The file boot in images.zip can be written to floppy with dd or RAWRITE.EXE to make a kernel boot disk.<br>
If you want to compile your own kernel, download <var>dev86/Dev86-0.0.13.4.tar.gz</var> and <var>kernel/elks-0.0.67/elks-0.0.67.tar.gz</var> (or the latest versions) from linux.mit.edu, or one of the other sites. Unpack Dev86 them into /usr/src (or any other convenient directory), and elks into /usr/src/linux-86 then do...<br><br>
<kbd>tar -xvzf Dev86-0.0.13.tar.gz -C /usr/src<br>
tar -xvzf elks-0.0.67.tar.gz -C /usr/src</kbd><br><br>
The development environment will be created in /usr/src/linux-86, and the kernel source in /usr/src/elks. Next you have  to build the development tools, which include the <b>bcc</b> compiler:<br><br>
<kbd>cd /usr/src/linux-86<br>make install</kbd><br><br>
Next, compile the kernel:<br><br>
<kbd>cd /usr/src/elks<br># Build kernel<br>make config<br>make dep<br>make</kbd><br><br>
Make config works in the same way as the main Linux kernel. The default configuration will work on almost all systems. Don't change any of the options unless you know what you are doing. (If you're used to building Linux kernels with gcc, you'll be amazed at how quick this is! :-) The result is a floppy disk image called "Image", which you can copy to a formatted floppy and boot from.<br><br>
<kbd>dd if=Image of=/dev/fd0</kbd><br><br>
or<br><br>
<kbd>make disk</kbd><br><br>
You should now be able to boot with this disk, but you won't get much further without a root floppy disk for it to mount. You can either use the image file root provided in images.zip, or make your own. You'll need to use bcc to compile an 'init' program and make a root minix filesystem. This is explained further down.<br>

<h4><a name="2.3">Q2.3. I get an error saying that /usr/include/linux/vm86.h does not exist.</a></h4>
Edit <kbd>/usr/include/sys/vm86.h</kbd> and change...<br><br>
<code>#include &lt;linux/vm86.h&gt;</code><br><br>
...to...<br><br>
<code>#include &lt;asm/vm86.h&gt;</code><br><br>
...instead.<br>

<h4><a name="2.4">Q2.4. How do I make an 'init' for ELKS?</a></h4>
After the ELKS kernel has booted it will  run /bin/init. A real version of 'init' is being prepared for inclusion in the tiny-utils package, also on linux.mit.edu. A very basic init and login is included in the sysutils part of the elkscmd package which is distributed with each release. The kernel code has recently been changed so that it loads /bin/init instead of /bin/sh.<br>
To install init and login compile them both with...<br><br>
<kbd>bcc -0 -O -ansi -s init.c -o<br>bcc -0 -O -ansi -s login.c -o login</kbd><br><br>
<var>-0 </var>selects 8086 code generation,<br>
<var>-O </var>enables optimisation,<br>
<var>-ansi </var>enables ansi-style function prototypes (only), and<br>
<var>-s </var>strips symbols out of the binary.<br><br>
...and copy them into the /bin directory of your root disk. The login program requires an <var>/etc/passwd</var> and a <var>/etc/group</var> file, and a <var>/bin/sh</var> (or other depending on the entry in <var>/etc/passwd</var>. As of kernel 0.0.56 sash now works and is being used as </var>/bin/sh</var> by most people. It can be found in <var>elkscmd.tar.gz</var>. For best results copy <var>/etc/passwd</var> and <var>/etc/group</var> from a standard linux distribution  onto your root disk so that <kbd>ls -l</kbd> works okay, and <var>/usr/lib/liberror.txt</var> so that sash error reporting works. A version of ash is also included which does work under ELKS, but is much larger, and may not work at all on machines with &lt;640K of memory.<br>

<h4><a name="2.5">Q2.5. How do I make a root filesystem disk?</a></h4>
For most people the root filesystem included in images.zip should be ideal, and can be used to create a root disk under Linux as follows:<br><br>
<kbd>dd if=root of=/dev/fd0 bs=8192</kbd><br><br>
Under DOS, RAWRITE.EXE can be used instead.<br>
You need to create a minix floppy containing the appropriate bits and pieces. This file should contain init, login, and sh in <var>/bin/</var> and passwd and group in <var>/etc/</var>, as well as three ttys for init in <var>/dev/</var>.<br>
<i>Note: /dev/tty is different to normal Linux which uses (5,0)</i><br><br>
<pre>mkdir /usr/src/root86			# make a directory
cd /usr/src/root86
mkdir dev				# create directorys in it
cd dev
mknod tty1 c 4 0			#create the required devices
mknod tty2 c 4 1
mknod tty3 c 4 2
mknod fd0 b 3 128
cd ..
mkdir bin
cd bin
cp &lt;path-to-elkscmd-init&gt; init		# copy in essential binaries
cp &lt;path-to-elkscmd-login&gt; login
cp &lt;path-to-elkscmd-sash&gt; sh
cd ..
mkdir etc
cd etc
cp &lt;path-to-skeleton-passwd&gt; passwd	# add required files for login
cp &lt;path-to-skeleton-group&gt; group
cd ..
fdformat /dev/fd0H1440			# if floppy not yet formatted
mkfs.minix -n14 /dev/fd0 1440
mount -t minix /dev/fd0 /a		# need a mount point "/a"
cp -pR /usr/src/root86/* /a
umount /a</pre><br>
Some distributions use <var>/dev/fd0u1440</var> instead of <var>/dev/fd0H1440</var>. You should removed passwords from the passwd file as they are not yet suported, and make sure the shell entry for each user is /bin/sh for future compatability.<br>

Alternatively, if you have a 2.0.x kernel and mount-2.5k, you can use the loopback filesystem to create a disk image on your hard disk, and then dump it to floppy:<br><br>
<kbd>dd if=/dev/zero of=root.image bs=18k count=80<br>
losetup /dev/loop0 root.image<br>
mkfs -t minix /dev/loop0 1440<br>
mount -t minix /dev/loop0 /a<br>
...<br>
umount /a<br>
dd if=root.image of=/dev/fd0</kbd><br><br>

As of ELKS 0.0.53 floppy sizes other than 1.44M now work. Just follow the above intructions substituting the appropriate sizes in where required. However, because of the way 360K disks are written by 1.2Meg drives, the instructions below must be followed if you are trying to boot a machine with a 360K drive.<br>

<h4><a name="2.6">Q2.6. What if I have an XT with a 360K disk drive?</a></h4>
Preparing boot and root images to run on a different machine requires a little care, especially if the target machine has a 360K drive. 360K drives (5.25" DD) have 40-track heads, and 1.2MB (5.25" HD) have 80-track heads. A 1.2MB drive can read 360K disks but not reliably write them, since it will write magnetic tracks which are half the width expected by a 360K drive.<br>
One solution is to fit a 360K drive as the second drive in your Linux PC - you can then format 360K disks with...<br><br>
<kbd>fdformat /dev/fd1d360</kbd><br><br>
...and create filesystems as usual. Otherwise, you will need to create a floppy
 disk image file, transfer it to the PC which has the 360K drive (e.g. using
 a serial cable), then use "rawrite" under DOS to recreate the disk from
the  image file.<br>

<h4>Boot disks</h4>
The 'Image' file can be written to any type of floppy disk and will boot successfully, so all you need to do is transfer the file and use 'rawrite' to make the target disk.<br>
Root disks are now autodetected so you no longer have to re-compile for disk sizes other than 1.44Mb.<br>

<h4>Root disks</h4>
You can prepare a 360K root image on a larger drive - when you enter the mkfs command substitute '360' for the size  of the filesystem. Once you have copied the files to this disk, unmount it, then you can create a disk image file from it:<br><br>
<kbd>dd if=/dev/fd0 of=root.image bs=1k count=360</kbd><br><br>
This image can then be transferred to the target and written out using 'rawrite' as before. If you use the loopback filesystem this step is not necessary.<br>

<h4>RAM limitations</h4>
0.0.44 expected there to be 640K RAM available. However if you do not have 640K the problems with <var>DEF_INITSEG</var> and <var>DEF_SETUPSEG</var> have now been fixed in later versions so you will not have to change anything.<br>

<h4><a name="2.7">Q2.7. How do a change root device of boot images?</a></h4>
Version 0.0.62 boot disk was compiled to use the second floppy drive as a root disk because the wait_for_keypress() function was broken. You can get round this if you only have one floppy drive  by using a hex editor to change the root device no. in the image.<br>
If you get an error about root disk mount failing on device 03c0, load the boot image into a hex editor and look for c003h somewhere near the start of the image and change it to 8003h. (c003h is 03c0 in Intel's backwards byte ordering). This should work for any version,  but it is not clear whether the address of the byte to edit varies between version. <a href="MailTo:jose@cnct.com">jose@cnct.com</a> reports that in 0.0.62 boot image, the two bytes are at 0adf - oade.<br>
      
<h4><a name="2.8">Q2.8. How do I install to ELKS to harddisk?</a></h4>
As of version 0.0.65 it is possible to install ELKS root disk on a harddisk and then create a boot floppy that uses this. There still some bugs but it is more usable than a root floppy.<br>
First create a partition with fdisk. Any version of fdisk will be able to do this, but the current root disk only supports bd?1-4, which are primary partitions, and if you already have a DOS primary partition you will not be able to make a second primary partition with DOS fdisk. The version of fdisk included on the ELKS 0.0.67 root disk is still young code, but seems to work fine on my system.<br>
Having created the partition, boot ELKS from boot and root floppies, and create a filesystem using mkfs. It is safe to use ELKS fdisk to check you know the correct device name for the partition you want to create the filesystem on. To create the filesystem type...<br><br>
<kbd>mkfs /dev/bd?? &lt;size&gt;</kbd><br><br>
...where bd?? is the correct partition, and size is the size of the partition in Kbyte blocks. &lt;size&gt; cannot be more than 32M. E.g. To make a filesystem on the first partition on the slave disk, which is a 20M partition type:<br><br>
<kbd>mkfs /dev/bdb1 20000</kbd><br><br>
Now mount the partition on the /mnt mount point by typing...<br><br>
<kbd>mount /dev/bd?? /mnt</kbd><br><br>
...where <i>bd??</i> is the correct partition.<br>
The root directory of the new partition may look a bit corrupted and it may not be possibly to use ls from <var>/mnt</var>. I am not sure why mkfs is generating slightly corrupt filesystems, but I am working on it.<br><br>

Create the essential directories on the new filesystem as follows:<br><br>
<kbd>cd /mnt<br>
mkdir bin dev etc home mnt root<br>
mkdir usr usr/lib<br>
mkdir var var/log var/run<br>
mkdir /mnt/home/user?....</kbd><br><br>
          
Now copy essential files. You will need many more than these for a decent system but here are the essentials and some of the more useful ones:<br><br>
<kbd>cd /bin<br>
cp -v cp init getty login ls mount pwd sh umount /mnt/bin/<br>
cd /etc<br>
cp -v group passwd /mnt/etc/<br>
cp /usr/lib/liberror.txt /mnt/usr/lib/<br>
touch /mnt/var/run/utmp</kbd><br><br>
Finally create the essentail devices:<br><br>
<kbd>cd /mnt/dev<br>
for N in 0 1 2 3 ; do mknod tty$N c 4 $N ; done<br>
mknod fd0 b 3 128<br>
mknod fd1 b 3 192<br>
for N in '' 1 2 3 4 ; do mknod bda$N b 3 $[$N+0] ; done<br>
for N in '' 1 2 3 4 ; do mknod bdb$N b 3 $[$N+64] ; done<br>
cd /</kbd><br><br>
Now unmount the new partition with:<br><br>
<kbd>umount /dev/bd??</kbd><br><br>
You will now need to re-compile a new kernel with the correct root device selected. To do this edit <var>include/linuxmt/config.h</var> in the ELKS kernel sources, and changed the <var>CONFIG_ROOTDEV</var> from 0x380 to the device number of the partition. The last two digits must be the minor number of the partition in hex. The minor number can be found from the list above in the far right column. E.g. The minor number for bdb3 is 67, which is 43 in hex, so the <var>ROOT_DEV</var> value is 0x343.<br><br>
When you have done this, type...<br><br>
<kbd>make disk</kbd><br><br>
...to build a new kernel floppy, and reboot  the ELKS machine with this new boot disk. The new root should mount, but may give a warning, and the system come up as normal, but much faster than from floppy. As before the root directory may be corrupted, but it should be possible to change to other directories normally, and the system should work otherwise normally.<br>

<h4><a name="2.9">Q2.9. I get errors building Dev86 on recent Linux systems?</a></h4>
There are two issues with building Dev86 on recent systems which are known to be a problem under RedHat 6.0.
<ol><li>Firstly a conflict with recent glibc means that a <var>FILE *</var> can no longer be initialised as pointing to standard IO. A fix is in the works for this problem.
	<li>The version of ar shipped with some Linux systems can no longer deal with bcc format .o files. A new ar program has been written for Dev86 and will be included in the next release. In the meantime <a href="mailto:greg@censoft.com">Greg Haerr</a> has made the  new version available from the <a href="ftp://microwindows.censoft.com/pub/microwindows/ar">ftp://microwindows.censoft.com/pub/microwindows/ar</a> ftp server.</ol><br>
      
<h4><a name="2.10">Q2.10. I get errors building elkscmd ?</a></h4>
Errors similar to the following may be experienced building elkscmd if Dev86 was not built correctly against a recent kernel:<br><br>
<code>undefined symbol: _setsid<br>undefined symbol: _fchown</code><br><br>
This is caused because the Dev86 did not pick up the list of system calls from the current kernel source. A similar  problem can occur if Dev86 does not find the kernel include directories, and build links to them in bcc's standard include directory:<br><br>
<samp>ps.c:2.26: error: cannot find include file linuxmt/sched.h</samp><br><br>
The solution to both these problems is as follows:
<ul><li>Make sure the line near the top of the Dev86 top level Makefile that defines ELKSSRC points to the correct directory  on your system.
	<li>Rebuild and re-install the libc portion of Dev86.<br><kbd>make library<br>make install-lib</kbd><br><br>
	<li>Check that /usr/bcc/include/linuxmt and /usr/bcc/include/arch are links to elks/include/linuxmt and elks/include/arch respectively, wherever you happen to keep your kernel source. If not, rmove the directories, and put in the links manually.<br><kbd>rm -rf /usr/bcc/include/linuxmt /usr/bcc/include/arch<br>ln -s /usr/src/elks/include/linuxmt /usr/bcc/include<br>ln -s /usr/src/elks/include/arch /usr/bcc/include</kbd><br><br>
	<li>Check that linux-86/libc/syscall.dat is the same as elks/arch/i86/kernel/syscall.dat. If not copy the version from the kernel into place to force it, and then rebuild and re-install Dev86.<br><kbd>cd /usr/src/linux-86<br>cp /usr/src/elks/arch/i86/kernel/syscall.dat libc/syscall/syscall.dat<br>cp /usr/src/elks/arch/i86/kernel/syscall.dat libc/syscall/syscall.dev86<br>make library<br>make install-lib</kbd><br></ul>
elkscmd should now build correctly.<br>

<h4><a name="2.11">Q2.11. I get warnings building elkscmd</a></h4>
Warnings similar to the following may be experienced building elkscmd:<br><br>
<samp>ld86: warning: _utmpname redefined in file /usr/local/bcc/lib/bcc/i86/libc.a(utnt.o); using definition in utent.o></samp><br><br>
These are caused because elkscmd contains patched version of files from the standard C library. Once these patched version have been well tested they will be integrated into libs, and removed from Dev86.

<hr align="center" width="90%"><br>
<h3><a name="3">Section 3 - Using ELKS</a></h3>
<h4><a name="3.1">Q3.1. Can I run bcc binaries under Linux?</a></h4>
Yes - by loading a kernel module you can run ELKS binaries directly. This makes development of programs to run under ELKS much less painful, since you can test them on your normal Linux system  (although they might not work under ELKS, if your program uses a kernel facility which is not yet implemented).<br><br>
<kbd>cd /usr/src/linux-86/elksemu<br>make module<br>insmod binfmt_elks.o</kbd><br><br>
Note that you will need to rerun the 'insmod' each time you reboot. There are some sample bcc programs you can try in /usr/src/linux-86/tests (such as a version of 'wc').<br>
If when making the module you get an error saying "modversions.h: no such file or directory" then you need to edit the  Makefile to remove the reference to this file, i.e.:<br><br>
<kbd>MODCFLAGS=-D__KERNEL__ -Wall -Wstrict-prototypes -O2 \<br>	-fomit-frame-pointer -fno-strength-reduce -pipe \<br>-m486 -DCPU=486 -DMODULE -DMODVERSIONS</kbd><br>      

<h4><a name="3.2">Q3.2. Can I boot ELKS under DOSEMU ?</a></h4>
Yes. ELKS can boot inside dosemu 0.63.1.36 running under Linux 2.0.7, and probably other combinations as well. Make sure your floppy drive is configured in <var>/etc/dosemu.conf</var>, and use the -A flag to dos or xdos if necessary to force a floppy boot.<br><br>
<code>floppy { device /dev/fd0 threeinch }</code><br>

<hr align="center" width="90%">
<h3><a name="4">Section 4 - Contributing to ELKS</a></h3>
<h4><a name="4.1">Q4.1. Can I contribute to the ELKS project ?</a></h4>
Yes! Just like any other Open Source project, ELKS can always use more volunteers. The system is quite simple relative to Linux so even people with relatively little experience can make a useful contribution.<br>
ELKS is now managed using <a href="http://sf.net/">Source Forge</a> which is an extremely useful service offered by <a href="http://www.valinux.com/">VA Linux</a>. In order to contribute to ELKS you will need to register for an account on Source Forge. The ELKS project page on Source Forge can be found <a href="http://sf.net/project/elks/">here</a>.<br>

<h4><a name="4.2">Q4.2. What needs to be done ?</a></h4>
Some idea of jobs that have been identified can be gained by looking at the Oustanding projects, and Bugs pages on the  main website. These pages are automatically generated from the TODO and BUGS  files in the kernel source tree.<br>    
Outside of the kernel there is alot of work to be done to put together the linux 8086 distribution which uses ELKS as its kernel. Most of the work involves porting existing utilities to run under ELKS.<br>

<h4><a name="4.3">Q4.3. What is CVS ?</a></h4>
CVS is the revision control system used to manage the source code of the elks kernel and the elkscmd package. You can use CVS to obtain the very latest version of the source code, look through  the revision history, and more experienced developers with accounts can use it to commit changes they have made to the code.<br><br>
ELKS CVS is now hosted on SourceForge.Net so, for details on getting an account see the link on CVS from the <a href="http://sf.net/project/elks/">ELKS project page</a>.

<h4><a name="4.4">Q4.4. Where do I get CVS from ?</a></h4>
Most distributions of Linux now include CVS, so you should first check your distribution to determine whether it is an optional package that hasn't yet been installed. If that is the case,  you should install that package.<br>
The latest version of CVS can be downloaded from <a href="http://elks.sf.net/faq/www.cvshome.org">www.cvshome.org</a> if you need to upgrade, and a manual for CVS is available online at the same site.<br>

<h4><a name="4.5">Q4.5. How do I use CVS without an account ?</a></h4>
SourceForge.Net offer full anonymous CVS services by default. Full information can be found on the CVS page linked from the <a href="http://sf.net/project/elks/">ELKS project page</a> on Source Forge.<br>
          
<hr align="center" width="90%">
<h3><a name="5">Section 5 - Unanswered questions</a></h3>
<dl><dt>Answers to these questions would be appreciated!
		<dd><h4><a name="5.1">Q5.1. Can I start ELKS from DOS, like LOADLIN.EXE does for Linux ?</a></h4><a href="MailTo:gabel@physik.uni-kl.de">Steffen Gabel</a> has written a package which can do this called <a href="http://www.geocities.com/SiliconValley/Lakes/4535/">BootELKS</a>, and would very much like to hear from anyone who uses it, or has problems.
		<dd><h4><a name="5.2">QA.2. My palmtop has a RAMdrive. Can ELKS access it ? <i>(When/if ELKS gets an MS-DOS filesystem, that is)</i></a></h4>
		<dd><h4><a name="5.3">QA.3. Can I combine the boot and root floppies ?</a></h4><br><pre>&gt; From: Bar-David Yedidya &lt; @math.tau.ac.il=""&gt;
&gt;
&gt; Today I managed to combine root/boot disks using LILO. It just
&gt; worked!
&gt;
&gt; I created /boot on the floppy, copied Image and boot.b to it,
&gt; put in /etc (on the floppy) lilo.conf with this:
&gt;
&gt;	boot=/dev/fd0
&gt;	compact
&gt;	image=/boot/Image
&gt;	label=lin16
&gt;
&gt; did lilo -r /mnt and Hopla!
&gt;
&gt; I didn't look at the kernel sources yet to compare the boot
&gt; code of linux and linux-16, but I guess they act the same,
&gt; and that's why lilo worked.</pre><br>
There are reports this broke under the recent ELKS versions (&gt;0.0.46?)<br>
<i>Note: Will this work on pre 386 machines ?</i><br>
Chad Page is working on a single disk system which should be in the next version.</dl>
